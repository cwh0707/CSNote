# 二叉树的遍历

### 1.二叉树的定义

```c++
//树节点的定义
struct TreeNode{
  int val;
  TreeNode* left;
  TreeNode* right;
  TreeNode(int x): val(x), left(NULL), right(NULL){}
};
```

```python
class TreeNode:
	def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None
```

### 2.二叉树的遍历

​		二叉树的遍历主要分为两种：递归写法和迭代写法。其中迭代写法就是模拟一个栈

#### 2.1 迭代写法

> 其中迭代写法有一种统一的形式，就是当处理节点和遍历节点两者的操作没有同时进行的话，那么我们可以引入一个null标记来完成统一这个操作，我刚开始在尝试使用一个while(!stack.empty())来实现的时候，发现需要pop两次，但是对于中间节点如何不置标记的话，那么就会出现一个死循环的现象，所以应该是在中间节点入栈的时候打上标记。talk is cheap,show me your code.

+ 先序遍历

```c++
vector<int> ans;

vector<int> preOrder(TreeNode* root){
  if(root == null){
    return vector<int>();
  }
  stack<TreeNode*> st;
  st.push(root);
  while(!st.empty()){
    TreeNode* t = st.top();
    if(t != null){  
      st.pop(); //防止t重复使用 很重要
      st.push(t);
      st.push(null); //打上处理标签
      if(t->right) st.push(t->right);
      if(t->left) st.push(t->left);
    }else{  //t为null的情况 要么是叶子节点 要么就是处理节点的那个标志为
      st.pop(); //先将null推出
      t = st.pop(); //拿新的栈顶元素
      st.pop();
      ans.push(t.val); //当前栈顶元素压入答案序列 ans中
    }
  }
}
```

+ 中序遍历

```c++
vector<int> ans;

vector<int> InOrder(TreeNode* root){
  if(root == null){
    return vector<int>();
  }
  stack<TreeNode*> st;
  st.push(root);
  while(!st.empty()){
    TreeNode* t = st.top();
    if(t != null){  
      st.pop(); //防止t重复使用 很重要
      if(t->right) st.push(t->right);
      
      st.push(t);
      st.push(null); //打上处理标签
      
      if(t->left) st.push(t->left);
    }else{  //t为null的情况 要么是叶子节点 要么就是处理节点的那个标志为
      st.pop(); //先将null推出
      t = st.pop(); //拿新的栈顶元素
      st.pop();
      ans.push(t.val); //当前栈顶元素压入答案序列 ans中
    }
  }
}
```

+ 后序遍历

```
vector<int> ans;

vector<int> postOrder(TreeNode* root){
  if(root == null){
    return vector<int>();
  }
  stack<TreeNode*> st;
  st.push(root);
  while(!st.empty()){
    TreeNode* t = st.top();
    if(t != null){  
      st.pop(); //防止t重复使用 很重要
      if(t->right) st.push(t->right);
      if(t->left) st.push(t->left);
      
      st.push(t);
      st.push(null); //打上处理标签
      
    }else{  //t为null的情况 要么是叶子节点 要么就是处理节点的那个标志为
      st.pop(); //先将null推出
      t = st.pop(); //拿新的栈顶元素
      st.pop(); //推出栈顶
      ans.push(t.val); //当前栈顶元素压入答案序列 ans中
    }
  }
}
```

#### 2.2 递归写法 

> 只需要注意ans定义的位置，定义在递归函数内，以及作为参数，以及定义在递归函数外都有不同的含义，注意之间的区分，做的题目还是有点少了，总结的太少了。

+ 先序遍历 leetcode 144

```python
def PreOrder(root):
  if root == None:
    return []
  ans = []
  	def preOr(root):
      if root:
        ans.append(root.val)
        preOr(root.left)
        preOr(root.right)
  preOr(root)
  return ans
```

+ 中序遍历 leetcode 94

```python
def PreOrder(root):
  if root == None:
    return []
  ans = []
  	def preOr(root):
      if root:
        preOr(root.left)
        ans.append(root.val)
        preOr(root.right)
  preOr(root)
  return ans
```

+ 后序遍历 leetcode 145

```python
def PreOrder(root):
  if root == None:
    return []
  ans = []
  	def preOr(root):
      if root:
        preOr(root.left)
        preOr(root.right)
        ans.append(root.val)
  preOr(root)
  return ans
```

### 3. 二叉树的层序遍历 

