# 二叉树的遍历

### 1.二叉树的定义

```c++
//树节点的定义
struct TreeNode{
  int val;
  TreeNode* left;
  TreeNode* right;
  TreeNode(int x): val(x), left(NULL), right(NULL){}
};
```

```python
class TreeNode:
	def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None
```

### 2.二叉树的遍历

​		二叉树的遍历主要分为两种：递归写法和迭代写法。其中迭代写法就是模拟一个栈

#### 2.1 迭代写法

> 其中迭代写法有一种统一的形式，就是当处理节点和遍历节点两者的操作没有同时进行的话，那么我们可以引入一个null标记来完成统一这个操作，我刚开始在尝试使用一个while(!stack.empty())来实现的时候，发现需要pop两次，但是对于中间节点如何不置标记的话，那么就会出现一个死循环的现象，所以应该是在中间节点入栈的时候打上标记。talk is cheap,show me your code.

+ 先序遍历

```c++
vector<int> ans;

vector<int> preOrder(TreeNode* root){
  if(root == null){
    return vector<int>();
  }
  stack<TreeNode*> st;
  st.push(root);
  while(!st.empty()){
    TreeNode* t = st.top();
    if(t != null){  
      st.pop(); //防止t重复使用 很重要
      st.push(t);
      st.push(null); //打上处理标签
      if(t->right) st.push(t->right);
      if(t->left) st.push(t->left);
    }else{  //t为null的情况 要么是叶子节点 要么就是处理节点的那个标志为
      st.pop(); //先将null推出
      t = st.pop(); //拿新的栈顶元素
      st.pop();
      ans.push(t.val); //当前栈顶元素压入答案序列 ans中
    }
  }
}
```

+ 中序遍历

```c++
vector<int> ans;

vector<int> InOrder(TreeNode* root){
  if(root == null){
    return vector<int>();
  }
  stack<TreeNode*> st;
  st.push(root);
  while(!st.empty()){
    TreeNode* t = st.top();
    if(t != null){  
      st.pop(); //防止t重复使用 很重要
      if(t->right) st.push(t->right);
      
      st.push(t);
      st.push(null); //打上处理标签
      
      if(t->left) st.push(t->left);
    }else{  //t为null的情况 要么是叶子节点 要么就是处理节点的那个标志为
      st.pop(); //先将null推出
      t = st.pop(); //拿新的栈顶元素
      st.pop();
      ans.push(t.val); //当前栈顶元素压入答案序列 ans中
    }
  }
}
```

+ 后序遍历

```
vector<int> ans;

vector<int> postOrder(TreeNode* root){
  if(root == null){
    return vector<int>();
  }
  stack<TreeNode*> st;
  st.push(root);
  while(!st.empty()){
    TreeNode* t = st.top();
    if(t != null){  
      st.pop(); //防止t重复使用 很重要
      if(t->right) st.push(t->right);
      if(t->left) st.push(t->left);
      
      st.push(t);
      st.push(null); //打上处理标签
      
    }else{  //t为null的情况 要么是叶子节点 要么就是处理节点的那个标志为
      st.pop(); //先将null推出
      t = st.pop(); //拿新的栈顶元素
      st.pop(); //推出栈顶
      ans.push(t.val); //当前栈顶元素压入答案序列 ans中
    }
  }
}
```

#### 2.2 递归写法 

> 只需要注意ans定义的位置，定义在递归函数内，以及作为参数，以及定义在递归函数外都有不同的含义，注意之间的区分，做的题目还是有点少了，总结的太少了。

+ 先序遍历 leetcode 144

```python
def PreOrder(root):
  if root == None:
    return []
  ans = []
  	def preOr(root):
      if root:
        ans.append(root.val)
        preOr(root.left)
        preOr(root.right)
  preOr(root)
  return ans
```

+ 中序遍历 leetcode 94

```python
def PreOrder(root):
  if root == None:
    return []
  ans = []
  	def preOr(root):
      if root:
        preOr(root.left)
        ans.append(root.val)
        preOr(root.right)
  preOr(root)
  return ans
```

+ 后序遍历 leetcode 145

```python
def PreOrder(root):
  if root == None:
    return []
  ans = []
  	def preOr(root):
      if root:
        preOr(root.left)
        preOr(root.right)
        ans.append(root.val)
  preOr(root)
  return ans
```

### 3. 二叉树的层序遍历 

> 二叉树的层次遍历本质上就是一个BFS，所以说就是一个BFS的模版套就可以了，使用一个辅助数据机构也就是队列来实现，从集合的角度来看的话，就是初始状态先入队，然后从队首元素看能连接到哪些元素，并将这些元素入队即可，也可以一层一层的遍历

#### 3.1 模版（迭代写法）

```c++
queue<TreeNode*> q;
q.push(root); //初始状态入队
int depth = 1;  //也可以统计深度
while(!q.empty()){
	int size = q.size(); //可以获取当前层需要处理的节点个数
	for(int i = 0; i < size; i++){  //对当前层的元素进行操作
		TreeNode *t = q.front();
		q.pop(); //记得出队 防止元素重复处理
		// 对该层可以访问到的节点入队 对于这两个if判断是必要的 为了防止对一个空节点进行处理
		if(t->left) q.push(t->left);
		if(t->right) q.push(t->right);
	}
	depth += 1; //对于深度可以加1 出层了啊
}

```

ps：根据这个模版可以解决一类问题，例如求最大深度，最小深度，在每一层中寻找最大值，求每一层中的平均值，将每一层的节点连接起来形成一个链表

#### 3.2 递归写法

> 对于层次遍历的递归写法这件事，需要考虑到递归函数其实传入的是一个左右节点的关系，也就是说传入的其实本质上还是一个节点，并非是一颗树，对于如果是一颗树的情况还需要特殊判断，在后面判断树是否对称会学到，要体会递归函数传入是一个节点是怎么操作的，当传入是一棵树又是如何来处理的，比较一下

```c++
vector<vector<int>> order;

void layerOr(TreeNode* root,int depth){
    //对于树这个来说，对于单个节点只需要判断是否为空节点 很重要
    if(root == nullptr) return ;
    //对每层的单个节点来说
    order[depth].push_back(root->val);
    layerOr(root->left,depth + 1);
    layerOr(root->right,depth + 1);
}
```

PS：对于递归函数传参，地址传引用和设置全局变量其实是差距不大的。

### 4. 判断二叉树是否对称

> 1. 递归传入的参数两颗树，判断两棵树是否对称
> 2. 递归边界的判定，对于树节点是否为空需要特判
> 3. 对于每层的操作需要仔细辨别
